# Testing Strategy Implementation Plan

## Approach

- **Coverage target**: ~60-70% initially (critical paths: matcher, profiler, handlers)
- **pgvector**: Mock `_find_similar_users()` and `get_embedding()` — no Docker needed
- **Telegram handlers**: Direct handler invocation with aiogram's own `MockedBot` pattern (adapted from their test suite) — real Message/CallbackQuery objects with bot injected via `.as_(bot)`, outgoing API calls captured via `bot.get_request()`
- **Database**: In-memory SQLite with savepoint-based test isolation
- **Always**: `uv run pyright` before `uv run pytest`, commit after each bite-sized piece

## Decisions Made

- State machine tests (testing field assignment) were **dropped** — they can't meaningfully fail since there's no transition validation logic. The value is in testing the SQL queries and handler conditional logic instead.
- `tests/factories.py` deferred — inline `_create_user`/`_create_match` helpers are sufficient for now

---

## Progress

### Phase 1: Test Infrastructure

- [x] Add test dependencies to `pyproject.toml` (`pytest-async-sqlalchemy`, `factory-boy`, `pytest-cov`)
- [x] Create `tests/conftest.py` — session-scoped engine + connection, function-scoped session with nested transaction (savepoint) rollback
- [x] Create `tests/test_database.py` — smoke tests proving isolation works even with `session.commit()`
- [x] Create `tests/test_placeholder.py` — basic pytest setup verification

### Phase 2: Critical Integration Tests

- [x] `tests/integration/test_matcher.py` — **15 tests** covering:
  - No users → `AllUsersMatched`
  - Single user, no candidates → participation record (`unmatched`)
  - Seeker + provider → match found (`pending`)
  - Round exhaustion when all users tried
  - Inactive / no-embedding / no-role users excluded
  - Pending match blocking: `qualified` blocks both sides
  - `a_accepted` blocks non-responder (user_b), not the accepter (user_a)
  - `b_accepted` blocks non-responder (user_a), accepter (user_b) is free
  - Round-robin picks oldest `profile_updated_at` first
  - Re-matching logic (exclusion query):
    - Disqualified + profile updated → re-matching allowed
    - Disqualified + no updates → re-matching blocked
    - Rejected matches → never re-matched (even with updates)
    - Connected matches → never re-matched (even with updates)
- [x] `tests/integration/test_profiler.py` — **6 tests** covering:
  - New profile → embedding generated, state = "ready"
  - Update with same `matching_summary` → embedding skipped
  - Update with changed `matching_summary` → embedding regenerated
  - Update sets state to "updated"
  - Activation sets state to "active"
  - Reset clears all profile fields + chat history

### Phase 3: Handler Tests (User-Facing Flows)

- [x] `tests/handlers/test_start_command.py` — **5 tests** covering:
  - New user: greeting message, Chat created with empty history
  - Existing user with matching_summary: reset warning with confirmation keyboard
  - Existing user with role: reset warning
  - Existing user with chat history: reset warning
  - Existing user with pending user_prompt: reset warning
- [x] `tests/handlers/test_match_acceptance.py` — **5 tests** covering:
  - User A accepts first: status → `a_accepted`
  - User B accepts first: status → `b_accepted`
  - Second user accepts (a_accepted → connected): both notified
  - User A completes b_accepted match → connected
  - User rejects: status → `rejected`
- [x] `tests/handlers/test_conversation.py` — **2 tests** covering:
  - Single message creates generation with budget mocking
  - Multiple rapid messages append to user_prompt, reuse pending generation

### Phase 4: Essential Unit Tests

- [x] ~~`tests/unit/test_user_model.py`~~ — **SKIPPED**: `User.can_match_with()` and `User.has_role` were unused and removed from the codebase. All matching logic is handled by SQL queries in `MatcherService`.

### Phase 5: Remaining Matcher Coverage

- [x] Re-matching logic in `test_matcher.py`:
  - Disqualified match + profile updated → re-match allowed
  - Disqualified match + no update → excluded
  - Rejected/connected match → never re-matched

### Phase 6: Verification & CI

- [ ] Enable tests in CI (uncomment step in `.github/workflows/ci.yml`)
- [ ] Run `uv run pytest --cov=src/mitko` to verify coverage target
- [ ] Update CLAUDE.md with testing patterns
- [ ] Update README.md with testing section

### Optional (Lower Priority)

- [ ] Concurrent message handling (FOR UPDATE lock)
- [ ] Round advancement logic in matching scheduler
- [ ] Budget interval calculation
- [ ] `tests/factories.py` with factory-boy (if inline helpers get unwieldy)

---

## Current State (35 tests, all passing)

```
tests/test_database.py                       2 tests  (fixture isolation proof)
tests/integration/test_matcher.py            15 tests (core matching SQL + re-matching exclusion)
tests/integration/test_profiler.py           6 tests  (profile CRUD + embedding logic)
tests/handlers/test_start_command.py         5 tests  (/start command flows)
tests/handlers/test_match_acceptance.py      5 tests  (match accept/reject state machine)
tests/handlers/test_conversation.py          2 tests  (message handling, generation creation)
```

## Bug Fixes From Testing

- **SQLite concurrent operations**: Tests revealed that `asyncio.gather` with multiple DB operations on the same session causes "concurrent operations are not permitted" errors with SQLite. Fixed by removing `asyncio.gather` for same-session DB calls in:
  - `handle_message`: get_or_create_user + get_or_create_chat
  - `handle_match_accept`: get_user for both users
  - `handle_reset_confirm`: get_or_create_user + get_or_create_chat
  - `MatchGeneration._fetch_users`: get_user for both users
  - `MatchGeneration._notify_users_simple`: send_to_user for both users
- **Timezone handling**: SQLite stores naive datetimes (no timezone info). Fixed `_format_time_delta` to handle both naive (SQLite) and aware (PostgreSQL) datetimes by adding UTC timezone to naive values before subtraction.

## Infrastructure Improvements

- **PostgreSQL compatibility in SQLite tests**: Registered custom SQLite functions (`greatest()`, `least()`) in `conftest.py` to enable testing production SQL queries that use PostgreSQL-specific functions. Accesses the raw `sqlite3.Connection` via `aiosqlite_conn._conn` to register sync functions.
- **Testing private methods**: Used `# pyright: ignore[reportPrivateUsage]` for test cases that directly verify internal query-building logic in `MatcherService._build_match_exclusion_query()`.

## Code Cleanup

- **Removed unused User model methods**:
  - `User.has_role` property — unused, role checks done in SQL
  - `User.roles_display` property — unused, no user-facing role display
  - `User.can_match_with()` method — unused, matching logic in `MatcherService` SQL queries
